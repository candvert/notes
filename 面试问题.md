- [操作系统](#操作系统)
	- [进程和线程的区别](#进程和线程的区别)
	- [进程调度算法有哪些](#进程调度算法有哪些)
	- [什么是大端，小端，如何判断大端小端](#什么是大端，小端，如何判断大端小端)
	- [什么是孤儿进程，什么是僵尸进程](#什么是孤儿进程，什么是僵尸进程)
	- [进程通信的方式有哪些](#进程通信的方式有哪些)
	- [进程有哪几种状态](#进程有哪几种状态)
	- [死锁是什么，产生的条件，如何预防死锁](#死锁是什么，产生的条件，如何预防死锁)
	- [虚拟内存和物理内存](#虚拟内存和物理内存)
	- [分页，分段](#分页，分段)
	- [动态分区分配算法有哪几种](#动态分区分配算法有哪几种)
- [计算机网络](#计算机网络)
	- [TCP三次握手四次挥手过程](#TCP三次握手四次挥手过程)
	- [TCP握手为什么是三次，不是两次，四次挥手，为什么是四次](#TCP握手为什么是三次，不是两次，四次挥手，为什么是四次)
	- [TCP如何实现可靠传输](#TCP如何实现可靠传输)
	- [HTTP和HTTPS的区别](#HTTP和HTTPS的区别)
	- [GET和POST的区别](#GET和POST的区别)
	- [HTTPS加解密的过程是怎么样的](#HTTPS加解密的过程是怎么样的)
	- [浏览器从输入URL开始到页面显示内容，中间发生了什么](#浏览器从输入URL开始到页面显示内容，中间发生了什么)
	- [ARP协议是怎么实现的，是怎么找到MAC地址的](#ARP协议是怎么实现的，是怎么找到MAC地址的)
	- [TCP粘包拆包](#TCP粘包拆包)
	- [TCP和UDP的区别](#TCP和UDP的区别)
	- [HTTP1.0，1.1，2.0区别](#HTTP1.0，1.1，2.0区别)
	- [HTTP状态码](#HTTP状态码)
	- [进程有哪些状态](#进程有哪些状态)
	- [为什么需要time_wait](#为什么需要time_wait)
- [C++](#C++)
	- [面向对象的三大特征](#面向对象的三大特征)
	- [C++中的四种类型转换](#C++中的四种类型转换)
	- [C++中的多态](#C++中的多态)
	- [虚表指针和虚函数表的初始化](#虚表指针和虚函数表的初始化)
	- [堆和栈的区别](#堆和栈的区别)
	- [malloc实现](#malloc实现)
- [数据库](#数据库)
	- [MySQL索引，以及它们的好处和坏处](#MySQL索引，以及它们的好处和坏处)
	- [事务的ACID特性](#事务的ACID特性)
	- [事务隔离级别](#事务隔离级别)
- [Linux](#Linux)
	- [常用的Linux命令](#常用的Linux命令)
	- [gdb常见的调试命令](#gdb常见的调试命令)
	- [静态库和动态库如何制作及使用](#静态库和动态库如何制作及使用)
	- [静态库和动态库的区别](#静态库和动态库的区别)
	- [select，poll，epoll的区别](#select，poll，epoll的区别)
- [其他问题](#其他问题)
	- [软件开发流程](#软件开发流程)

# 操作系统
## 进程和线程的区别
```
进程是操作系统分配资源的基本单位，而线程是CPU调度和执行的基本单位
进程间的资源和地址空间是相互独立的，而同一进程的线程共享资源
进程切换的开销大，而线程切换的开销相对较小
```
## 进程调度算法有哪些
```
先来先服务 first-come first-servered(FCFS)，短作业优先 shortest job first(SJF)，时间片轮转，高响应比优先，优先级调度，多级反馈队列
```
## 什么是大端，小端，如何判断大端小端
```cpp
// 小端指的是一个整数的低位字节存放在低地址处，大端指的是一个整数的低位字节存放在高地址处


// 判断大端小端
#include <cstdio>
int main() {
    union {
    short value;
    char bytes[sizeof(short)];
    } test;

    test.value = 0x0102;
    if (test.bytes[0] == 2)
        printf("小端字节序");
    else if (test.bytes[0] == 1)
        printf("大端字节序");

    return 0;
}
```
## 什么是孤儿进程，什么是僵尸进程
```
孤儿进程是指一个父进程退出后，它的子进程仍在运行，这些子进程便成为了孤儿进程，孤儿进程会被init进程收养，孤儿进程一般不会产生任何危害

僵尸进程是指子进程结束，而父进程还没有回收子进程的资源，那么子进程就成为了僵尸进程
```
## 进程通信的方式有哪些
```
无名管道，有名管道（FIFO），消息队列，信号，信号量，共享内存，套接字
```
## 进程有哪几种状态
```
创建、就绪、执行、阻塞、终止
```
## 死锁是什么，产生的条件，如何预防死锁
```
两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁

互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放；请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放；不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放；环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链

预防死锁：银行家算法
```
## 虚拟内存和物理内存
```
虚拟内存是一种内存管理技术，操作系统给每个进程分配一个私有的、独立的虚拟内存空间，从进程的角度来看，它们的内存地址完全是隔离的。另外，操作系统提供了一种机制，让不同的虚拟内存和不同的物理内存建立映射关系，这样各进程不会起冲突。虚拟内存允许进程访问页面时才将其加载到物理内存上，而不需要一次性将所有的页面都加载到物理内存上，这让进程的运行内存远大于实际的物理内存
```
## 分页，分段
```
分页和分段都是属于非连续分配方式，相对于连续分配方式没有外部碎片，同时能将平均内部碎片控制在半个页的大小。

分页是从计算机的内存分配的角度考虑，能提高内存利用率，分段则是从程序员的角度考虑，方便共享和保护。

段页式：一个程序一个段表，每个段一个页表
```
## 动态分区分配算法有哪几种
```
首次适应算法，最佳适应算法，最坏适应算法，邻近适应算法
```
# 计算机网络
## TCP三次握手四次挥手过程
## TCP握手为什么是三次，不是两次，四次挥手，为什么是四次
## TCP如何实现可靠传输
## HTTP和HTTPS的区别
## GET和POST的区别
## HTTPS加解密的过程是怎么样的
## 浏览器从输入URL开始到页面显示内容，中间发生了什么
## ARP协议是怎么实现的，是怎么找到MAC地址的
## TCP粘包拆包
## TCP和UDP的区别
## HTTP1.0，1.1，2.0区别
## HTTP状态码
## 进程有哪些状态
## 为什么需要time_wait
# C++
## 面向对象的三大特征
## C++中的四种类型转换
## C++中的多态
## 虚表指针和虚函数表的初始化
## 堆和栈的区别
## malloc实现
# 数据库
## MySQL索引，以及它们的好处和坏处
## 事务的ACID特性
```
事务具有四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持续性（Durability）

原子性：
事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做
一致性：
事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态
隔离性：
一个事务的执行不能被其他事务干扰。即一个事务的内部操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰
持续性：
也称永久性，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的


事务ACID特性可能遭到破坏的因素有：
（1）多个事务并行运行时，不同事务的操作交叉执行
（2）事务在运行过程中被强行停止
在第一种情况下，数据库管理系统必须保证多个事务的交叉运行不影响这些事务的原子性；在第二种情况下，数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响
```
## 事务隔离级别
# Linux
## 常用的Linux命令
```
cd：切换当前目录
ls：查看当前目录中的文件
grep：匹配符合指定模式的行
cp：复制文件
mv：移动文件
rm：删除文件
ps：查看进程信息
top实时查看进程信息
cat：打印文件内容
pwd：打印当前工作目录
less：查看文件内容
ln：创建硬链接和软链接
```
## gdb常见的调试命令
## 静态库和动态库如何制作及使用
```
静态链接库
	命名 lib<name>.a
	生成 ar rcs lib<name>.a file1.o file2.o
	使用 gcc main.c -L<dir> -l<name>
		 或gcc main.c <dir>/lib<name>.a

动态链接库
	命名 lib<name>.so
	生成 gcc -fPIC -shared -o lib<name>.so file.c
	
		 或gcc -c -fPIC file.c
		 gcc -o lib<name>.so -shared file.o
	使用 gcc main.c -L<dir> -l<name>
		 或gcc main.c <dir>/lib<name>.a
```
## 静态库和动态库的区别
```
静态库
优点：静态库被打包到应用程序中加载速度快；发布程序无需提供静态库，移植方便
缺点：相同的库文件数据可能在内存中被加载多份，消耗系统资源，浪费内存；库文件更新需要重新编译项目文件，生成新的可执行程序，浪费时间

动态库
优点：动态库更新只需要替换库文件，无需重新编译应用程序
缺点：加载速度比静态库慢，发布程序需要提供依赖的动态库
```
## select，poll，epoll的区别
# 其他问题
## 软件开发流程
```
需求分析、系统设计、开发实现、测试、部署、维护和迭代
```
