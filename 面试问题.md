- [操作系统](#操作系统)
	- [进程和线程的区别](#进程和线程的区别)
	- [进程调度算法有哪些](#进程调度算法有哪些)
	- [什么是大端，小端，如何判断大端小端](#什么是大端，小端，如何判断大端小端)
	- [什么是孤儿进程，什么是僵尸进程](#什么是孤儿进程，什么是僵尸进程)
	- [进程通信的方式有哪些](#进程通信的方式有哪些)
	- [进程有哪几种状态](#进程有哪几种状态)
	- [死锁是什么，产生的条件，如何预防死锁](#死锁是什么，产生的条件，如何预防死锁)
	- [虚拟内存和物理内存](#虚拟内存和物理内存)
	- [分页，分段](#分页，分段)
	- [动态分区分配算法有哪几种](#动态分区分配算法有哪几种)
- [计算机网络](#计算机网络)
	- [TCP三次握手过程](#TCP三次握手过程)
	- [TCP四次挥手过程](#TCP四次挥手过程)
	- [TCP握手为什么是三次，不是两次](#TCP握手为什么是三次，不是两次)
	- [TCP挥手为什么是四次](#TCP挥手为什么是四次)
	- [TCP如何实现可靠传输](#TCP如何实现可靠传输)
	- [HTTP和HTTPS的区别](#HTTP和HTTPS的区别)
	- [GET和POST的区别](#GET和POST的区别)
	- [HTTPS加解密的过程是怎么样的](#HTTPS加解密的过程是怎么样的)
	- [浏览器从输入URL开始到页面显示内容，中间发生了什么](#浏览器从输入URL开始到页面显示内容，中间发生了什么)
	- [ARP协议是怎么实现的，是怎么找到MAC地址的](#ARP协议是怎么实现的，是怎么找到MAC地址的)
	- [TCP粘包拆包](#TCP粘包拆包)
	- [TCP和UDP的区别](#TCP和UDP的区别)
	- [HTTP1.0，1.1，2.0区别](#HTTP1.0，1.1，2.0区别)
	- [HTTP状态码](#HTTP状态码)
	- [进程有哪些状态](#进程有哪些状态)
	- [为什么需要time_wait](#为什么需要time_wait)
- [C++](#C++)
	- [面向对象的三大特性](#面向对象的三大特性)
	- [C++中的四种类型转换](#C++中的四种类型转换)
	- [C++中的多态](#C++中的多态)
	- [虚表指针和虚函数表的初始化](#虚表指针和虚函数表的初始化)
	- [堆和栈的区别](#堆和栈的区别)
	- [malloc实现](#malloc实现)
- [数据库](#数据库)
	- [MySQL索引，以及它们的好处和坏处](#MySQL索引，以及它们的好处和坏处)
	- [索引失效](#索引失效)
	- [事务的ACID特性](#事务的ACID特性)
	- [事务隔离级别](#事务隔离级别)
- [Linux](#Linux)
	- [常用的Linux命令](#常用的Linux命令)
	- [gdb常见的调试命令](#gdb常见的调试命令)
	- [静态库和动态库如何制作及使用](#静态库和动态库如何制作及使用)
	- [静态库和动态库的区别](#静态库和动态库的区别)
	- [select，poll，epoll的区别](#select，poll，epoll的区别)
- [其他问题](#其他问题)
	- [常用设计模式](#常用设计模式)
	- [软件开发流程](#软件开发流程)

# 操作系统
## 进程和线程的区别
```
进程是操作系统分配资源的基本单位，而线程是CPU调度和执行的基本单位
进程间的资源和地址空间是相互独立的，而同一进程的线程共享资源
进程切换的开销大，而线程切换的开销相对较小
```
## 进程调度算法有哪些
```
先来先服务 first-come first-servered(FCFS)，短作业优先 shortest job first(SJF)，时间片轮转，高响应比优先，优先级调度，多级反馈队列
```
## 什么是大端，小端，如何判断大端小端
```cpp
// 小端指的是一个整数的低位字节存放在低地址处，大端指的是一个整数的低位字节存放在高地址处


// 判断大端小端
#include <cstdio>
int main() {
    union {
    short value;
    char bytes[sizeof(short)];
    } test;

    test.value = 0x0102;
    if (test.bytes[0] == 2)
        printf("小端字节序");
    else if (test.bytes[0] == 1)
        printf("大端字节序");

    return 0;
}
```
## 什么是孤儿进程，什么是僵尸进程
```
孤儿进程是指一个父进程退出后，它的子进程仍在运行，这些子进程便成为了孤儿进程，孤儿进程会被init进程收养，孤儿进程一般不会产生任何危害

僵尸进程是指子进程结束，而父进程还没有回收子进程的资源，那么子进程就成为了僵尸进程
```
## 进程通信的方式有哪些
```
无名管道，有名管道（FIFO），消息队列，信号，信号量，共享内存，套接字，文件
```
## 进程有哪几种状态
```
创建、就绪、执行、阻塞、终止
```
## 死锁是什么，产生的条件，如何预防死锁
```
两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁

互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放；请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放；不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放；环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链

预防死锁：银行家算法
```
## 虚拟内存和物理内存
```
虚拟内存是一种内存管理技术，操作系统给每个进程分配一个私有的、独立的虚拟内存空间，从进程的角度来看，它们的内存地址完全是隔离的。另外，操作系统提供了一种机制，让不同的虚拟内存和不同的物理内存建立映射关系，这样各进程不会起冲突。虚拟内存允许进程访问页面时才将其加载到物理内存上，而不需要一次性将所有的页面都加载到物理内存上，这让进程的运行内存远大于实际的物理内存
```
## 分页，分段
```
分页和分段都是属于非连续分配方式，相对于连续分配方式没有外部碎片，同时能将平均内部碎片控制在半个页的大小。

分页是从计算机的内存分配的角度考虑，能提高内存利用率，分段则是从程序员的角度考虑，方便共享和保护。

段页式：一个程序一个段表，每个段一个页表
```
## 动态分区分配算法有哪几种
```
首次适应算法，最佳适应算法，最坏适应算法，邻近适应算法
```
# 计算机网络
## TCP三次握手过程
![](images/network_3.png)
```
简短描述：
	首先，客户进程向处于监听状态的服务器进程发送连接请求报文段，客户进程进入同步已发送状态。服务器收到后，向客户发送确认报文段，服务器进程进入同步收到状态。接着客户收到服务器的确认后，向服务器发送确认报文段。这时TCP连接已经建立，客户进程进入已建立连接状态。最后服务器收到客户的确认后，也进入已建立连接状态。



详细描述：
	服务器进程开始时处于LISTEN状态，准备接受客户进程的连接请求。然后客户进程向服务器发送连接请求报文段，首部中的同步位SYN为1，同时选择一个初始序号seq为x。TCP规定，SYN报文段（即SYN为1的报文段）不能携带数据，但要消耗掉一个序号。这时，客户进程进入SYN-SENT（同步已发送）状态。
	服务器进程收到连接请求报文段后，向客户发送确认。在确认报文段中把SYN位和ACK位都置1，确认号ack为x + 1，同时选择一个初始序号seq为y。这个报文段也不能携带数据，但同样要消耗掉一个序号。这时服务器进程进入SYN-RCVD（同步收到）状态。
	客户进程收到服务器的确认后，向服务器发送确认报文段，确认报文段的ACK置1，确认号ack为y + 1，序号seq为x + 1。TCP的标准规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号。这时，TCP连接已经建立，客户进程进入ESTABLISHED（已建立连接）状态。
	当服务器进程收到客户的确认后，也进入ESTABLISHED状态。
```
## TCP四次挥手过程
![](images/network_4.png)
```
简短描述：
	这时，客户进程和服务器进程都处于已建立连接状态，双方都可释放连接。假设客户进程先向服务器进程发送连接释放报文段，并停止发送数据，主动关闭TCP连接。这时客户进程进入终止等待1状态。服务器进程收到连接释放报文段后即发出确认报文段，服务器进程进入关闭连接状态。因而客户到服务器这个方向上的连接就释放了。这时的TCP连接处于半关闭状态。客户收到来自服务器的确认后，就进入终止等待2状态，等待服务器发出的连接释放报文段。若服务器已经没有要向客户发送的数据，则服务器发出的连接释放报文段，这时服务器进入最后确认状态，等待客户的确认。客户在收到服务器的连接释放报文段后，必须对此发出确认，经过2MSL后，客户进入关闭状态。



详细描述：
	数据传输结束后，通信的双方都可释放连接。客户进程和服务器进程都处于ESTABLISHED状态，客户进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。客户进程把连接释放报文段首部的终止控制位FIN置1，其序号seq = u，它等于前面已传送过的数据的最后一个字节的序号加1。这时客户进程进入FIN-WAIT-1（终止等待1）状态，等待服务器的确认。TCP规定，FIN报文段即使不携带数据，也要消耗掉一个序号。
	服务器收到连接释放报文段后即发出确认，确认号是ack = u + 1，而这个报文段自己的序号是v，等于服务器进程前面已传送过的数据的最后一个字节的序号加1。然后服务器进程就进入CLOSE-WAIT（关闭连接）状态。TCP服务器进程这时应通知高层应用进程，因而从客户到服务器这个方向的连接就释放了，这时的TCP连接处于半关闭（half-close）状态，即客户已经没有数据要发送了，但服务器若发送数据，客户仍要接收。也就是说，从服务器进程到客户进程这个方向的连接并未关闭，这个状态可能会持续一段时间。
	客户收到来自服务器的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待服务器发出的连接释放报文段。
	若服务器已经没有要向客户发送的数据，其应用进程就通知TCP释放连接。这时服务器发出的连接释放报文段必须使FIN = 1.现假定服务器的序号为w（在半关闭状态服务器可能又发送了一些数据）。服务器还必须重复上次已发送过的确认号ack = u + 1。这时服务器就进入LAST-ACK（最后确认）状态，等待客户的确认。
	客户在收到服务器的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack = w + 1，而自己的序号是seq = u + 1（根据TCP标准，前面发送过的FIN报文段要消耗掉一个序号）。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过2MSL后，客户进程才进入到CLOSED状态。
```
## TCP握手为什么是三次，不是两次
```
	主要是为了防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误。
	所谓已失效的连接请求报文段是这样产生的。即客户发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到达服务器。本来这是一个早已失效的报文段。但服务器收到此失效的连接请求报文段后，就误认为是客户又发出一次新的连接请求。于是就向客户发出确认报文段，同意建立连接。假定不采用报文握手，那么只要服务器发出确认，新的连接就建立了。
	由于现在客户并没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据。但服务器却以为新的运输连接已经建立了，并一直等待客户发来数据。服务器的许多资源就这样白白浪费了。
```
## TCP挥手为什么是四次
```

```
## TCP如何实现可靠传输
```

```
## HTTP和HTTPS的区别
```

```
## GET和POST的区别
```

```
## HTTPS加解密的过程是怎么样的
```

```
## 浏览器从输入URL开始到页面显示内容，中间发生了什么
```

```
## ARP协议是怎么实现的，是怎么找到MAC地址的
```

```
## TCP粘包拆包
```

```
## TCP和UDP的区别
```

```
## HTTP1.0，1.1，2.0区别
```

```
## HTTP状态码
```

```
## 进程有哪些状态
```

```
## 为什么需要time_wait
```

```
# C++
## 面向对象的三大特性
```
封装、继承、多态
1. 封装。封装就是将内部数据和操作隐藏起来，只暴露对外界的接口。
2. 继承。
```
## C++中的四种类型转换
```
static_cast
const_cast
reinterpret_cast
dynamic_cast
```
## C++中的多态
```

```
## 虚表指针和虚函数表的初始化
```

```
## 堆和栈的区别
```

```
## malloc实现
```

```
# 数据库
## MySQL索引，以及它们的好处和坏处
```

```
## 索引失效
```

```
## 事务的ACID特性
```
事务具有四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持续性（Durability）

原子性：
事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做
一致性：
事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态
隔离性：
一个事务的执行不能被其他事务干扰。即一个事务的内部操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰
持续性：
也称永久性，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的


事务ACID特性可能遭到破坏的因素有：
（1）多个事务并行运行时，不同事务的操作交叉执行
（2）事务在运行过程中被强行停止
在第一种情况下，数据库管理系统必须保证多个事务的交叉运行不影响这些事务的原子性；在第二种情况下，数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响
```
## 事务隔离级别
```

```
# Linux
## 常用的Linux命令
```
cd：切换当前目录
ls：查看当前目录中的文件
grep：匹配符合指定模式的行
cp：复制文件
mv：移动文件
rm：删除文件
ps：查看进程信息
top实时查看进程信息
cat：打印文件内容
pwd：打印当前工作目录
less：查看文件内容
ln：创建硬链接和软链接
```
## gdb常见的调试命令
```

```
## 静态库和动态库如何制作及使用
```
静态链接库
	命名 lib<name>.a
	生成 ar rcs lib<name>.a file1.o file2.o
	使用 gcc main.c -L<dir> -l<name>
		 或gcc main.c <dir>/lib<name>.a

动态链接库
	命名 lib<name>.so
	生成 gcc -fPIC -shared -o lib<name>.so file.c
	
		 或gcc -c -fPIC file.c
		 gcc -o lib<name>.so -shared file.o
	使用 gcc main.c -L<dir> -l<name>
		 或gcc main.c <dir>/lib<name>.a
```
## 静态库和动态库的区别
```
静态库
优点：静态库被打包到应用程序中加载速度快；发布程序无需提供静态库，移植方便
缺点：相同的库文件数据可能在内存中被加载多份，消耗系统资源，浪费内存；库文件更新需要重新编译项目文件，生成新的可执行程序，浪费时间

动态库
优点：动态库更新只需要替换库文件，无需重新编译应用程序
缺点：加载速度比静态库慢，发布程序需要提供依赖的动态库
```
## select，poll，epoll的区别
```

```
# 其他问题
## 常用设计模式
```

```
## 软件开发流程
```
需求分析、系统设计、开发实现、测试、部署、维护和迭代
```
