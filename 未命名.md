Go 模板是 Go 标准库 `text/template` 和 `html/template` 提供的文本生成引擎，用于动态生成内容。以下是核心语法和示例：

## 1. 基础模板结构
```go
package main

import (
    "os"
    "text/template"
)

func main() {
    tmpl := `Hello, {{.Name}}! Your score is {{.Score}}.
{{if .Passed}}Congratulations!{{else}}Try again.{{end}}`

    data := struct {
        Name   string
        Score  int
        Passed bool
    }{"Alice", 85, true}

    t := template.Must(template.New("test").Parse(tmpl))
    t.Execute(os.Stdout, data)
}
// 输出:
// Hello, Alice! Your score is 85.
// Congratulations!
```

## 2. 数据访问
```go
// 结构体字段
{{.User.Name}}

// 映射键值
{{.Dict.key}}

// 方法调用（需返回单值或值+error）
{{.GetDescription}}

// 全局函数
{{len .Items}}
```

## 3. 控制结构
### 条件判断
```go
{{if .Enabled}}
  Status: Enabled
{{else if .Pending}}
  Status: Pending
{{else}}
  Status: Disabled
{{end}}

{{/* 与条件 */}}
{{if and .User .User.Active}}
```

### 循环迭代
```go
{{range .Items}}
  Position: {{.}}  // 当前元素
{{end}}

{{range $index, $element := .Items}}
  {{$index}}: {{$element}}
{{end}}

// 空循环处理
{{range .Items}}
  {{.}}
{{else}}
  No items found
{{end}}
```

## 4. 函数与管道
```go
// 内置函数
{{printf "Value: %v" .Value}}
{{html "<script>"}}  // 转义HTML（html/template）
{{js "str"}}

// 自定义函数
t := template.New("").Funcs(template.FuncMap{
    "add": func(a, b int) int { return a + b },
})

// 管道操作
{{.Value | printf "%0.2f" | upper}}
{{.Time | formatTime "2006-01-02"}}
```

## 5. 变量与作用域
```go
{{$count := len .Items}}
{{$name := .UserName}}

{{with .UserProfile}}
  Email: {{.Email}}  // 当前作用域变为 UserProfile
  Original: {{$name}}  // 访问外部变量
{{end}}
```

## 6. 模板嵌套
```go
// 定义基础模板
const base = `
{{define "base"}}
<html>
  <body>
    {{template "content" .}}
  </body>
</html>
{{end}}`

// 子模板
const page = `
{{define "content"}}
  <h1>{{.Title}}</h1>
{{end}}`

t := template.Must(template.New("").Parse(base))
t = template.Must(t.Parse(page))
t.ExecuteTemplate(os.Stdout, "base", data)
```

## 7. 安全注意事项（html/template）
```go
// 自动转义
tmpl := `<div>{{.UserInput}}</div>`  // 用户输入会被转义

// 禁用转义（危险！）
{{.SafeHTML | safe}}  // 需要自定义 safe 函数

// URL 转义
<a href="/path?q={{.Query | urlquery}}">Link</a>
```

## 实际应用场景
1. **Web 页面渲染**（html/template）
2. **邮件模板生成**
3. **配置文件动态生成**
4. **代码生成工具**

## 常见错误处理
```go
t, err := template.New("").Parse(tmpl)
if err != nil {
    // 解析错误（语法问题）
}

err = t.Execute(writer, data)
if err != nil {
    // 执行错误（数据问题）
}
```

是否需要进一步了解特定场景的用法？例如 Web 开发中的布局模板或复杂数据结构的处理？



















在Python中，\`os.path.join()\` 是一个用于智能拼接文件路径的函数，它会根据操作系统的不同自动使用正确的路径分隔符。

## 基本语法
\`\`\`python
os.path.join(path1, path2, ...)
\`\`\`

## 主要特点

### 1. 自动处理路径分隔符
\`\`\`python
import os

# 在Windows上
print(os.path.join('C:', 'Users', 'Documents', 'file.txt'))
# 输出: C:\Users\Documents\file.txt

# 在Linux/Mac上
print(os.path.join('/home', 'user', 'documents', 'file.txt'))
# 输出: /home/user/documents/file.txt
\`\`\`

### 2. 处理绝对路径
\`\`\`python
import os

# 当遇到绝对路径时，会从该路径开始重新拼接
result = os.path.join('/home/user', '/documents', 'file.txt')
print(result)  # 输出: /documents/file.txt
\`\`\`

### 3. 处理空字符串
\`\`\`python
import os

# 空字符串会被忽略
result = os.path.join('path1', '', 'path2', 'file.txt')
print(result)  # 输出: path1/path2/file.txt
\`\`\`

## 实用示例

### 示例1：构建项目路径
\`\`\`python
import os

project_root = '/home/user/projects'
subdirectory = 'my_project'
filename = 'config.json'

full_path = os.path.join(project_root, subdirectory, filename)
print(full_path)
# 输出: /home/user/projects/my_project/config.json
\`\`\`

### 示例2：处理用户输入路径
\`\`\`python
import os

base_dir = '/var/www'
user_input = 'uploads/images/avatar.jpg'

safe_path = os.path.join(base_dir, user_input)
print(safe_path)
# 输出: /var/www/uploads/images/avatar.jpg
\`\`\`

### 示例3：跨平台兼容性
\`\`\`python
import os

# 这段代码在Windows和Linux上都能正常工作
config_path = os.path.join('config', 'settings', 'app.ini')
print(config_path)
# Windows: config\settings\app.ini
# Linux: config/settings/app.ini
\`\`\`

## 为什么使用 os.path.join()

1. **跨平台兼容性**：自动处理不同操作系统的路径分隔符
2. **代码可读性**：比手动拼接字符串更清晰
3. **安全性**：避免路径拼接错误
4. **维护性**：如果路径规则变化，只需修改一处

## 注意事项

\`\`\`python
import os

# 错误的方式 - 手动拼接
bad_path = 'path1' + '/' + 'path2' + '/' + 'file.txt'

# 正确的方式 - 使用 os.path.join()
good_path = os.path.join('path1', 'path2', 'file.txt')
\`\`\`

\`os.path.join()\` 是处理文件路径时的最佳实践，建议在需要拼接路径时总是使用它。